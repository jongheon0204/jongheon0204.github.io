---
layout: post
title: Round 635 (Div 2)
summary: 2020.04.15 23:35 ~ 02:05 (1522 -> 1411)
tag: [Div2]
date: 2020-04-16 09:45:00 +0900
---

### A. Ichihime and Triangle
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/A){: target="\_blank"}

숫자 a, b, c, d가 주어졌을 때 다음을 만족하는 x, y, z를 구하는 문제
* a<= x <=b
* b<= y <=c
* c<= z <=d
* x, y, z는 삼각형 변의 길이이다.
* y와 z를 c로 한다면 이등변 삼각형이 되기 때문에 x의 값이 1보다 크기만 하면 된다.

```c++
#include <iostream>
using namespace std;
int main(){
	int tc,a,b,c,d; cin>>tc;
	while(tc--){
		cin>>a>>b>>c>>d;
		// x = b, y = z = c로 한다면 이등변 삼각형이 된다.
		cout<<b<<' '<<c<<' '<<c<<'\n';
	}
}
```

### B. Kana and Dragon Quest game
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/B){: target="\_blank"}

h 값에 대해 (h/2) + 10 계산 최대 n번, h - 10 계산 최대 m번이 가능하다고 할때, h값이 0이하가 될수 있는지 검사.

* n번동안 (h/2) + 10 계산을 하면서 값이 오히려 커지면 그만둔다.
* h - 10 * m 계산을 한 후 0보다 작은지 검사한다.

```c++
#include <iostream>
using namespace std;
int main(){
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	int tc; cin>>tc;
	while(tc--){
		int x,n,m; cin>>x>>n>>m;
		int num = n+m;
		// n번동안 h/2 + 10 계산을 하는데 이때 계산을 한 후 값이 더 커지면 그만둔다.
		while(n--){
			int next = x/2 + 10;
			if(next < x) x = next;
			else break;
		}
		x -= (m*10);
		cout<<(x<=0 ? "YES\n" : "NO\n");
	}
}
```

### C. Linova and Kingdom 
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/C){: target="\_blank"}

n개의 노드로 이루어진 트리가 있을때, k개의 노드를 선택하고 루트로 가는 길중 선택하지 않은 노드의 개수가 최대를 구하는 문제이다.

* 간선이 주어졌을때, DFS로 각 노드의 레벨과 자식의 개수를 구한다.
* i번째 노드를 선택한다면 더할수 있는 값은 (level[i] - child[i])가 된다.
* 위의 값들을 정렬한 후 값들이 최대가 되는 노드 k개를 선택하면 된다.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#define vi vector<int>
#define ll long long
using namespace std;
 
vector<vi> edge;
vector<bool> isVisit;
vector<ll> child,level,node;
 
// 정렬 기준은 노드의 레벨 - 자식의 개수값 이다.
bool cmp(int a,int b){
	return (level[a] - child[a]) > (level[b] - child[b]);
}
 
ll Find(int cur,ll lev){
	isVisit[cur] = true;
	level[cur] = lev;
	int ret = 0;
	// 연결된 간선을 검사하면서 자식을 탐색한다.
	for(int i=0;i<edge[cur].size();i++){
		int next = edge[cur][i];
		if(isVisit[next]) continue;
		ret += Find(next,lev+1);
	}	
	// 자식의 개수를 반환해 주는데 자신까지 포함한 값을 반환한다
	return (child[cur] = ret) + 1;
}
 
int main(){
	ios_base::sync_with_stdio(false); cin.tie(NULL);
	ll n,k,ans = 0; cin>>n>>k;
	
	edge = vector<vi>(n);
	isVisit = vector<bool>(n);
	node = child = level = vector<ll>(n);
	for(int i=1,a,b;i<n;i++){
		cin>>a>>b;
		edge[a-1].push_back(b-1);
		edge[b-1].push_back(a-1);
		node[i] = i;
	}
 
	Find(0,0);
	
	sort(node.begin(),node.end(),cmp);
	// 정렬후 k개의 값을 더해주면 된다.
	for(int i=0;i<k;i++){
		int cur = node[i];
		ans += (level[cur] - child[cur]);	
	}
	cout<<ans;
}
```

### D. Xenia and Colorful Gems
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/D){: target="\_blank"}

### E. Kaavi and Magic Spell
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/E){: target="\_blank"}

### F. Yui and Mahjong Set 
[[문제 바로가기]](https://codeforces.com/contest/1337/problem/F){: target="\_blank"}
